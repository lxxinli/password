### AcWing 1064. 小国王

#### 题目描述

>### 1064. 小国王
>
>在 $n×n$ 的棋盘上放 $k$ 个国王，国王可攻击相邻的 $8$ 个格子，求使它们无法互相攻击的方案总数。
>
>#### 输入格式
>
>第一行两个整数，$N$, $V$，用空格隔开，分别表示物品种数和背包容积。
>
>#### 输出格式
>
>输出一个整数，表示最大价值。
>
>#### 数据范围
>
>$0<N≤1000$
>
>#### 输入样例：
>
>```
>
>```
>
>##### 输出样例：
>
>```
>
>```

#### 算法剖析

xxx

#### 完整C++ 代码

```c++

```

xxx













# 第一章 基础算法





## 二分查找

### AcWing 789. 数的范围

#### 题目描述

给定一个按照升序排列的长度为 $n$ 的整数数组，以及 $q$ 个查询。

对于每个查询，返回一个元素 $k$ 的起始位置和终止位置（位置从 $0$ 开始计数）。

如果数组中不存在该元素，则返回 `-1 -1`。

#### 输入格式

第一行包含整数 $n$ 和 $q$，表示数组长度和询问个数。

第二行包含 $n$ 个整数（均在 $1∼10000$ 范围内），表示完整数组。

接下来 $q$ 行，每行包含一个整数 $k$，表示一个询问元素。

#### 输出格式

共 $q$ 行，每行包含两个整数，表示所求元素的起始位置和终止位置。

如果数组中不存在该元素，则返回 `-1 -1`。

#### 数据范围

$1≤n≤100000$

$1≤q≤10000$

$1≤k≤10000$

#### 输入样例：

```
6 3
1 2 2 3 3 4
3
4
5
```

#### 输出样例：

```
3 4
5 5
-1 -1
```

---

#### 算法剖析







#### 完整C++ 代码





---

## 前缀和

### AcWing 795. 前缀和

#### 题目描述

输入一个长度为 $n$ 的整数序列。

接下来再输入 $m$ 个询问，每个询问输入一对 $l$, $r$。

对于每个询问，输出原序列中从第 $l$ 个数到第 $r$ 个数的和。

#### 输入格式

第一行包含两个整数 $n$ 和 $m$。

第二行包含 $n$ 个整数，表示整数数列。

接下来 $m$ 行，每行包含两个整数 $l$ 和 $r$，表示一个询问的区间范围。

#### 输出格式

共 $m$ 行，每行输出一个询问的结果。

#### 数据范围

$1≤l≤r≤n$,
$1≤n,m≤100000$,
$−1000≤$ 数列中元素的值 $≤1000$

#### 输入样例：

```
5 3
2 1 3 6 4
1 2
1 3
2 4
```

#### 输出样例：

```
3
6
10
```

---

#### 算法剖析

前缀和的思想用的挺多的,可以将多次的求一段连续区间和的时间复杂度从 $O(n^2)$ 优化到 $O(n)$

构造 $s_i=a_1+a_2+...+a_i$

通过提前预处理一个 $s$ 数组来存储累加和

#### 完整C++ 代码

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int n, m;
int s[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {   
        int a;
        cin >> a;
        s[i] = s[i - 1] + a;
    }
    while (m--)
    {
        int l, r;
        cin >> l >> r;
        cout << s[r] - s[l - 1] << endl;
    }
    return 0;
}
```

---

## 差分

### AcWing 797. 差分

#### 题目描述

有输入一个长度为 $n$ 的整数序列。

接下来输入 $m$ 个操作，每个操作包含三个整数 $l,r,c$，表示将序列中 $[l,r]$ 之间的每个数加上 $c$。

请你输出进行完所有操作后的序列。

#### 输入格式

第一行包含两个整数 $n$ 和 $m$。

第二行包含 $n$ 个整数，表示整数序列。

接下来 $m$ 行，每行包含三个整数 $l，r，c$，表示一个操作。

#### 输出格式

共一行，包含 $n$ 个整数，表示最终序列。

#### 数据范围

$1≤n,m≤100000$,
$1≤l≤r≤n$,
$−1000≤c≤1000$,
$−1000≤\ $整数序列中元素的值$\ ≤1000$

#### 输入样例：

```
6 3
1 2 2 1 2 1
1 3 1
3 5 1
1 6 1
```

#### 输出样例：

```
3 4 5 3 4 2
```

---

#### 算法剖析

构造 $B$ 数组：

使得：$a_i = b_1+b_2+...+b_i$

那么我们对 $B$ 数组进行一次前缀和操作就可以得到 $a_i$。

那么就可以在 $O(n)$ 的时间由 $B$ 数组反推出 $A$ 数组。

$B$ 数组有一个好处，可以在 $O(1)$ 的时间里将 $[l, r]$ 中每一个数加上 $c$ 。

通过令 $b_l + c$ , $b_{r+1} - c$ 即可。

#### 朴素解法 C++ 代码

由$\begin{cases}
        a_i = b_1+b_2+...+b_i\\
        a_{i-1} = b_1+b_2+...+b_{i-1}
    \end{cases}$$\Rightarrow b_i = a_{i}-a_{i-1}\ \ \ \ \ (1)$ 

直接利用公式 $(1)$ $b_i = a_{i}-a_{i-1}$ 来初始化 $B$ 数组。

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int n, m;
int a[N], b[N], s[N];

int main()
{
    cin >> n >> m;
    for (int i = 1;i <= n; i++)
    {
       cin >> a[i];
       b[i] = a[i] - a[i - 1];
    }
    while (m--)
    {
        int l, r, c;
        cin >> l >> r >> c;
        b[l] += c;
        b[r + 1] -= c;
    }

    for (int i = 1; i <= n; i++)
    {
        s[i] = s[i - 1] + b[i];
        cout << s[i] << " ";
    }
    return 0;
}
```

#### 优美解法 C++ 代码

一开始 $A, B$ 数组初值都为0，已经满足差分定义了。

此时每次读取后更新A数组的值 $a_i$，其实就可以看作是对 $A$ 数组 $[i, i]$ 区间上的每一个数加上 $a_i$, 所以直接复用后面的差分代码即可完成对 $B$ 数组的初始化。

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int n, m;
int a, b[N];

void insert(int l, int r, int c)
{
    b[l] += c;
    b[r + 1] -= c;
}

int main()
{
    cin >> n >> m;
    for (int i = 1;i <= n; i++)
    {
       cin >> a;
       insert(i, i, a);               // 点金之笔，代码复用
    }
    while (m--)
    {
        int l, r, c;
        cin >> l >> r >> c;
        insert(l, r, c);
    }

    for (int i = 1; i <= n; i++)
    {
        b[i] += b[i - 1];             // 直接偷懒不再用s数组来存前缀和了
        cout << b[i] << " ";
    }
    return 0;
}
```

---

## 位运算

求 $n$ 的第 $k$ 位数字: `n >> k & 1`

$\text{lowbit}$ 算法：返回 $n$ 的最后一位1的子串，如1100返回100，10010返回10:`lowbit(n) = n & -n`

证明：$n \ \& -n = n \ \& \ (∼ n + 1)$, $-n$ means 补码

---



# 第二章 数据结构

## 滚动数组

### AcWing21. 斐波那契数列

#### 题目描述

输入一个整数 $n$ ，求斐波那契数列的第 $n$ 项。

假定从 $0$ 开始，第 $0$ 项为 $0$。

#### 输入格式

共一行，包含两个整数 $n$ 和 $k$ 。

#### 输出格式

共一行，表示斐波那契数列的第 $n$ 项。

#### 数据范围

$0 \le n \le39$,


#### 输入样例：

```
36
```

#### 输出样例：

```
14930352
```

---

#### 算法剖析

如果只需要使用到相邻 $n$ 个状态的值，那么只需要开 $n$ 层数组即可，其中状态使用  $f(i\ \%\ n)$ 来表示即可

#### 完整 C++ 代码

```c++
#include <iostream>

using namespace std;

int dp[3];
int n;

int main()
{
    cin >> n;
    dp[1] = 1;
    for (int i = 2; i <= n; i++)
    {
        dp[i % 3] = dp[(i - 1) % 3] + dp[(i - 2) % 3];
    }
    
    cout << dp[n % 3] << endl;
    return 0;
}
```

---

## KMP

> KMP：一个人能走的多远不在于他在顺境时能走的多快，而在于他在逆境时多久能找到曾经的自己 

### AcWing 831. KMP字符串

#### 题目描述

给定一个字符串 $S$，以及一个模式串 $P$，所有字符串中只包含大小写英文字母以及阿拉伯数字。
模式串 $P$ 在字符串 $S$ 中多次作为子串出现。
求出模式串 $P$ 在字符串 $S$ 中所有出现的位置的起始下标。

#### 输入格式

第一行输入整数 $N$，表示模式串 $P$ 的长度。

第二行输入字符串 $P$。

第三行输入整数 $M$，表示字符串 $S$ 的长度。

第四行输入字符串 $S$。

#### 输出格式

共一行，输出所有出现位置的起始下标（下标从 $0$ 开始计数），整数之间用空格隔开。

#### 数据范围

$ 1≤N≤10^5 $

$ 1≤M≤10^6 $

#### 输入样例：

```
3
aba
5
ababa
```

#### 输出样例：

```
0 2
```

---

#### 算法剖析

$next[i]本质:模式串前i个字符的最长的一对相等的前后缀size(＝该前缀末端index)[下标从1开始]$
$如$:"$abab$", $size$=$2$

$每次循环开始的时候,j都=ne[i - 1]，下面分两种情况来讨论：$
$①.if\;\;p_{i}=p_{j+1}$
$\;\;\;\;\;\;\;\;\;\; ne[i] \gets ne[i - 1] + 1$
$②.if\;\;p_{i} \ne p_{j+1}$
$\;\;\;\;\;\;\;\;\;\; j \gets ne[j],再重新开始判断if\;(p_{i}=p_{j+1})$

```c++
// 求next数组过程:其实就是求最大前后缀长度，通过仿造下面KMP匹配的过程来求,可以将暴力求的o(n^2)复杂度降至o(n)
for (int i = 2, j = 0; i <= n; i++)           // 注意这里i得从2开始,因为默认ne[1]=0,如果这里i从1开始,很明显会导致ne[1]=1,最终代码会出现TLE
{
    while (j != 0 && p[i] != p[j + 1])  j = ne[j];   // 只要j没有退回起点,并且p[i]和p[j+1]不匹配,就可以通过next数组更新j
    if (p[i] == p[j + 1]) j++;   // 如果最终p[i]和p[j+1]相等,那么最长前后缀size就可以+1
    ne[i] = j;                   // 最后更新一下ne[i]
}
```

$每一次将字符串的s[i]和模式串的p[j + 1]进行匹配$

```c++
// KMP匹配过程:将s[i]与p[j + 1]进行匹配[当然这里为什么用j+1就说来话长了,毕竟当不匹配的时候是要对该下标前面的进行转移，所以与其用j-1，不如用j+1也就方便不越界了]
for (int i = 1, j = 0; i <= m; i++)
{
    while (j != 0 && s[i] != p[j + 1])  j = ne[j];   // 只要j没有退回起点,并且s[i]和p[j+1]不匹配,就可以通过next数组更新j
    if (s[i] == p[j + 1]) j++;                // 因为上面的循环结束有两种情况，1.j退回起点退无可退了，2.s[i]和p[j+1]终于匹配上了
    if (j == n)
    {
        cout <<  i - n << " ";                // 匹配成功,这里是根据题目要求的输出所有出现位置的起始下标（下标从0开始计数）
        j = ne[j];                           // 此时依旧使用next数组来更新使得省去已知匹配的前后缀
    }
}
```

$ \text{KMP} 算法可以视作状态机模型:基于字符串p的\text{KMP}自动机接受且仅接受以p为后缀的字符串，其接受状态为|p|。 $
$转移函数:$

$$ne(i, c) =
\begin{cases}
i + 1, & \text{if } p[i+1] = c \\
0, & \text{if } p[1] \neq c \land i = 0 \\
ne(\pi(i), c), & \text{if } p[i+1] \neq c \land i > 0
\end{cases}$$

#### 时间复杂度

$O(n+m)$

#### 完整C++ 代码

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 100010, M = 1000010;

char p[N], s[M];             // pattern:模式串
int ne[N];                  // next数组

int main() 
{
    int n, m;
    cin >> n >> p + 1 >> m >> s + 1;

    // 求next数组过程:其实就是求最大前后缀长度，通过仿造下面KMP匹配的过程来求,可以将暴力求的o(n^2)复杂度降至o(n)
    for (int i = 2, j = 0; i <= n; i++)           // 注意这里i得从2开始,因为默认ne[1]=0,如果这里i从1开始,很明显会导致ne[1]=1,最终代码会出现TLE
    {
        while (j != 0 && p[i] != p[j + 1])  j = ne[j];   // 只要j没有退回起点,并且p[i]和p[j+1]不匹配,就可以通过next数组更新j
        if (p[i] == p[j + 1]) j++;   // 如果最终p[i]和p[j+1]相等,那么最长前后缀size就可以+1
        ne[i] = j;                   // 最后更新一下ne[i]
    }

    // KMP匹配过程:将s[i]与p[j + 1]进行匹配[当然这里为什么用j+1就说来话长了,毕竟当不匹配的时候是要对该下标前面的进行转移，所以与其用j-1，不如用j+1也就方便不越界了]
    for (int i = 1, j = 0; i <= m; i++)
    {
        while (j != 0 && s[i] != p[j + 1])  j = ne[j];   // 只要j没有退回起点,并且s[i]和p[j+1]不匹配,就可以通过next数组更新j
        if (s[i] == p[j + 1]) j++;                // 因为上面的循环结束有两种情况，1.j退回起点退无可退了，2.s[i]和p[j+1]终于匹配上了
        if (j == n)
        {
            cout <<  i - n << " ";                // 匹配成功,这里是根据题目要求的输出所有出现位置的起始下标（下标从0开始计数）
            j = ne[j];                           // 此时依旧使用next数组来更新使得省去已知匹配的前后缀
        }
    }
}
```

---







# 第三章 搜索与图论



# 第四章 数学知识





# 第五章 动态规划

## DP问题初始化方式

**（小于等于，等于，大于）**

dp[i]:表示当体积`≤i`的所有情况集合下的最大价值[如**	AcWing2. 01背包问题**等]

```c++
// dp[0] = 0;       // 这种情况就是最基本的背包问题，无需特意初始化，只需要初值都是0就可以

......    

for (int j = m; j >= v; j--)   // 计算时严格保证任意状态下背包体积 >= 0
{
    dp[j] = max(dp[j], dp[j - v] + w);
}

......

cout << dp[m] << endl;         // 最大值就是简单的dp[m]
```

---

dp[i]:表示当体积`==i`的所有情况集合下的最大价值[如**AcWing12. 背包问题求具体方案**等]

```c++
memset(dp, -0x3f, sizeof dp);   // 初始化为∞（如果题目求max，就用+∞，求min，就用-∞）
dp[0] = 0;        // 对dp[0]作为起始点单独初始化,求最大价值就初始化为0，求方案数就初始化为1

......    

for (int j = m; j >= v; j--)    // 计算时严格保证任意状态下背包体积 >= 0
{
    dp[j] = max(dp[j], dp[j - v] + w);     
}

......

int res = 0;              // 注意这里是体积恰好为i的情况，所以最大值就不只是简单的dp[m]
for (int i = 0; i <= m; i++) res = max(res, dp[i]);      // 需要一层循环求结果
cout << res << endl;
```

---

dp[i]:表示当体积`≥i`的所有情况集合下的最小价值[如**AcWing1020. 潜水员**等]

```c++
memset(dp, 0x3f, sizeof dp);   // 初始化为∞（如果题目求max，就用+∞，求min，就用-∞）
dp[0] = 0;           // 对dp[0]作为起始点单独初始化,求最大价值就初始化为0，求方案数就初始化为1

......           

for (int j = m; j >= 0; j--)   // 计算时任意状态下背包的体积允许 < 0
{
    dp[j][k] = min(dp[j][k], dp[max(0, j-v1)][max(0, k-v2)]+w);   
}

......

cout << dp[m][n] << endl;     // 最大值需要自己判断，可能还是dp[m][n]
```

---

## 数字三角形模型

> 数字三角形模型应该算是dp中最简单的模型了



### AcWing 1018. 最低通行费

#### 题目描述

一个商人穿过一个 $N×N$ 的正方形的网格，去参加一个非常重要的商务活动。

他要从网格的左上角进，右下角出。

每穿越中间 $1$ 个小方格，都要花费 $1$ 个单位时间。

商人必须在 $(2N−1)$ 个单位时间穿越出去。

而在经过中间的每个小方格时，都需要缴纳一定的费用。

这个商人期望在规定时间内用最少费用穿越出去。

请问至少需要多少费用？

注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。

#### 输入格式

第一行是一个整数，表示正方形的宽度 $N$。

后面 $N$ 行，每行 $N$ 个不大于 $100$ 的正整数，为网格上每个小方格的费用。

#### 输出格式

输出一个整数，表示至少需要的费用。

#### 数据范围

$0<N≤100$

#### 输入样例：

```
5
1  4  6  8  10
2  5  7  15 17
6  8  9  18 20
10 11 12 19 21
20 23 25 29 33
```

#### 输出样例：

```
109
```

---

#### 算法剖析

这题说的看起来很复杂，商人必须在 $(2N−1)$ 个单位时间穿越出去，其实用贪心发现最快方式也就是每次只往右或者下走，时间正好是 $(2N−1)$ 所以这题其实就是一道数字三角形的简单模板

#### 完整C++ 代码

```c++
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 110;

int n;
int w[N][N];
int dp[N][N];

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) 
        for (int j = 1; j <= n; j++) 
            cin >> w[i][j];
    memset(dp, 0x3f, sizeof dp);          // 求min就设置无穷大，方便后面就不用写if判断语句了
    dp[0][1] = 0;                       
    for (int i = 1; i <= n; i++) 
        for (int j = 1; j <= n; j++)
            dp[i][j] = w[i][j] + min(dp[i - 1][j], dp[i][j - 1]);
    cout << dp[n][n] << endl;
    return 0;
}
```

---

## 最长上升子序列模型

### AcWing 895. 最长上升子序列

#### 题目描述

给定一个长度为 $N$ 的数列，求数值严格单调递增的子序列的长度最长是多少。

#### 输入格式

第一行包含整数 $N$。

第二行包含 $N$ 个整数，表示完整序列。

#### 输出格式

输出一个整数，表示最大长度。

#### 数据范围

$0<N≤1000$

$−10^9≤$ 数列中的数 $≤109$

#### 输入样例：

```
7
3 1 2 1 8 5 6
```

#### 输出样例：

```
4
```

---

#### 算法剖析

$f_i$ 表示所有以第 $i$ 个数结尾的上升子序列中的最大值

#### 完整C++ 代码

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int a[N], dp[N];

int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) {
        dp[i] = 1;
        for (int j = 1; j < i; j++) {
            if (a[i] > a[j]) dp[i] = max(dp[i], dp[j] + 1);
        }
    }
    int res = 0;
    for (int i = 1; i <= n; i++) res = max(res, dp[i]);
    cout << res << endl;
    return 0;
}
```

---

## 背包模型

### AcWing 5. 多重背包问题 II

#### 题目描述

有 $N$ 种物品和一个容量是 $V$ 的背包。

第 $i$ 种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是 $w_i$。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。

输出最大价值。

#### 输入格式

第一行两个整数，$N$, $V$，用空格隔开，分别表示物品种数和背包容积。

接下来有 $N$ 行，每行三个整数 $v_i$, $w_i$, $s_i$，用空格隔开，分别表示第 $i$ 种物品的体积、价值和数量。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

$0<N≤1000$
$0<V≤2000$
$0<v_i, w_i, s_i≤2000$

##### 提示：

本题考查多重背包的二进制优化方法。

#### 输入样例：

```
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

#### 输出样例：

```
10
```

---

#### 算法剖析

一个非常简洁的二进制优化自用板子

根据y总讲的AcWing7. 混合背包问题整理的板子，相当简洁还省空间

空间复杂度无需$O(n \log n)$,降为$O(max(n, log s))$

时间复杂度还是$O(n^2log n)$

#### 完整C++ 代码

```c++
#include <iostream>

using namespace std;

const int N = 2010;
int dp[N];

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) 
    {
        int v, w, s;
        cin >> v >> w >> s;
        for (int k = 1; k <= s; k *= 2)            // 把s拆成二进制形式，如 10 = 2^0 + 2^1 + 2^2 + 3
        {
            for (int j = m; j >= k * v; j--)       // 对上面的分开形式进行01背包
            {
                dp[j] = max(dp[j], dp[j - k * v] + k * w);
            }
            s -= k;
        }
        if (s) {                                   // 处理刚刚拆开的二进制的最后一位
            for (int j = m; j >= s * v; j--)
            {
                dp[j] = max(dp[j], dp[j - s * v] + s * w);
            }
        }
    }
    cout << dp[m] << endl;
    return 0;
}

```

---

## 状态机模型

### AcWing 1058. 股票买卖 V

#### 题目描述

给定一个长度为 $N$ 的数组，数组中的第 $i$ 个数字表示一个给定股票在第 $i$ 天的价格。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 $1$ 天)。

#### 输入格式

第一行包含整数 $N$，表示数组长度。

第二行包含 $N$ 个不超过 $10000$ 的正整数，表示完整的数组。

#### 输出格式

输出一个整数，表示最大利润。

#### 数据范围

$1≤N≤10^5$

#### 输入样例：

```
5
1 2 3 0 2
```

#### 输出样例：

```
3
```

---

#### 算法剖析

状态分为：1. 手中有货，2. 手中无货的第 $1$ 天，3. 手中无货的第 $\ge2$ 天

#### 完整C++ 代码

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 100010, INF = 0x3f3f3f3f;

int dp[N][3];         // dp[i][0]:有货, dp[i][1]:手中无货的第1天, dp[i][2]:手中无货的第≥2天

int main() {
    int n;
    cin >> n;
    memset(dp, -0x3f, sizeof dp);

    dp[0][2] = 0;
    for (int i = 1; i <= n; i++)
    {
        int w;
        cin >> w;
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - w);
        dp[i][1] = dp[i - 1][0] + w;
        dp[i][2] = max(dp[i - 1][2], dp[i - 1][1]);
    }
    cout << max(dp[n][1], dp[n][2]) << endl;
    return 0;
}
```

---

## 状态压缩DP

### AcWing 1064. 小国王

#### 题目描述

>### 1064. 小国王
>
>在 $n×n$ 的棋盘上放 $k$ 个国王，国王可攻击相邻的 $8$ 个格子，求使它们无法互相攻击的方案总数。
>
>#### 输入格式
>
>共一行，包含两个整数 $n$ 和 $k$ 。
>
>#### 输出格式
>
>共一行，表示方案总数，若不能够放置则输出$0$。
>
>#### 数据范围
>
>$1 \le n \le10$,
>$0 \le k \le n^2$
>
>#### 输入样例：
>
>```
>3 2
>```
>
>#### 输出样例：
>
>```
>16
>```

---

#### 算法剖析

$f(i,j,s)$:所有只摆在前$i$行，已经摆了$j$个国王，并且第$i$行摆放的状态是$s$的所有方案的集合。

首先我们来看看暴力一点的做法，虽然我们提前对符合条件的值进行了预处理，但是依旧会超时。因为我们最后还是在最后状态转移阶段还是在遍历每一个二进制数，虽然判断其合法性的操作提前进行了预处理来降低了部分时间复杂度，但是依旧需要$O(N \times K \times 2^n \times 2^n)$,在这一题大概是$10^9$,会超时。

#### 暴力做法 C++ 代码

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 12, M = N * N, S = 1 << N;

int dp[N][M][S];
bool st[S];
int cnt[S];

int main()
{
    int n, m;
    cin >> n >> m;
    dp[0][0][0] = 1;

    for (int i = 0; i < 1 << n; i++)
    {
        st[i] = true;
        int num = 0;
        for (int u = 0; u < n; u++)
        {
            if (i >> u & 1)
            {
                num++;
                if (num > 1) st[i] = false;
            }
            else num = 0;
        }
        if (num > 1) st[i] = false;
    }    

    for (int i = 0; i < 1 << n; i++)
    {
        for (int u = 0; u < n; u++)
        {
            if (i >> u & 1) cnt[i]++;
        }
    }

    for (int i = 1; i <= n; i++)
    {
        for (int j = 0; j <= m; j++)
        {
            for (int k = 0; k < 1 << n; k++)
            {
                for (int u = 0; u < 1 << n; u++)
                {
                    if (k & u) continue;
                    if (!st[k | u]) continue;
                    if (cnt[k] <= j) dp[i][j][k] += dp[i - 1][j - cnt[k]][u];
                }
            }
        }
    }

    int res = 0;
    for (int i = 0; i < 1 << n; i++) res += dp[n][m][i];
    cout << res << endl;
    return 0;
}
```

进一步思考：如果我们把所有可能符合的值在预处理阶段存下来，那么我们在最终状态转移的时候，岂不是其实只需要在这些值里进行遍历，那么时间复杂度就可以进一步降低。

#### 优化版本 C++ 代码
```c++
#include <iostream>
#include <cstring>
#include <vector>

using namespace std;

const int N = 12, S = N * N, M = 1 << N;

int n, m;
long long dp[N][S][M];
int cnt[M];
vector<int> state;
vector<int> head[M];

bool check(int state)
{
    for (int u = 0; u < n; u++)
    {
        if ((state >> u & 1) && (state >> u + 1 & 1))
            return false;
    }
    return true;
}

int count(int state)
{
    int res = 0;
    for (int u = 0; u < n; u++) 
        if (state >> u & 1)
            res++;
    return res;
}

int main()
{
    cin >> n >> m;
    dp[0][0][0] = 1;

    for (int i = 0; i < 1 << n; i++)                        
    {   
        if (check(i)) 
        {
            state.push_back(i);                  // 预处理出来所有的不存在连续两个1的可能情况，后续只对这些情况进行循环
            cnt[i] = count(i);                   // 预处理出1的个数
        }
    }   


    for (int i = 0; i < state.size(); i++)
    {
        for (int j = 0; j < state.size(); j++)
        {
            int a = state[i];
            int b = state[j];
            if ((a & b) == 0 && check(a | b))     // ！！！:这里写成if ((a & b == 0) && check(a | b))是错误的，因为优先级
            {
                head[a].push_back(b);
            }
        }
    }

    for (int i = 1; i <= n; i++)
    {
        for (int j = 0; j <= m; j++)
        {
            for (int a = 0; a < state.size(); a++)
            {
                for (int b = 0; b < head[state[a]].size(); b++)
                {   
                    int c = cnt[state[a]];
                    if (j >= c) dp[i][j][state[a]] += dp[i - 1][j - c][head[state[a]][b]];
                }
            }
        }
    }

    long long res = 0;
    for (int i = 0; i < 1 << n; i++) res += dp[n][m][i];
    cout << res << endl;         // 或是更简单的在上一步循环时到 i<=n+1 结束，此时 res=dp[n+1][0]; 
    return 0;
}
```

---

## 区间DP

### AcWing 282. 石子合并

#### 题目描述

> #### 282. 石子合并
>
> 设有 $N$ 堆石子排成一排，其编号为 $1,2,3,…,N$。
>
> 每堆石子有一定的质量，可以用一个整数来描述，现在要将这 $N$ 堆石子合并成为一堆。
>
> 每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。
>
> 例如有 $4$ 堆石子分别为 `1 3 5 2`， 我们可以先合并 $1、2$ 堆，代价为 $4$，得到 `4 5 2`， 又合并 $1、2$ 堆，代价为 $9$，得到 `9 2` ，再合并得到 $11$，总代价为 $4+9+11=24$；
>
> 如果第二步是先合并 $2、3$堆，则代价为 $7$，得到 `4 7`，最后一次合并代价为 $11$，总代价为 $4+7+11=22$。
>
> 问题是：找出一种合理的方法，使总的代价最小，输出最小代价。
>
> ####  输入格式
>
> 第一行一个数 $N$ 表示石子的堆数 $N$。
>
> 第二行 $N$ 个数，表示每堆石子的质量(均不超过 $1000$)。
>
> #### 输出格式
>
> 输出一个整数，表示最小代价。
>
> #### 数据范围
>
> $1≤n≤300$
>
> #### 输入样例：
>
> ```
> 4
> 1 3 5 2
> ```
>
> ##### 输出样例：
>
> ```
> 22
> ```

---

#### 算法剖析

这是区间 $\text{DP}$ 的一道经典的模板题，一般有两种解法：

* 迭代式：适合对于一维的情况

```
 for (int len = 2; len <= n; len++)                      // 一般就是先枚举区间长度len
     for (int L = 1; L + len - 1 <= n; L++)              // 然后枚举左端点
     {
		R = L + len - 1;                                 // 就可以推出右端点
     }
```

* 记忆化搜索：主要针对二维及以上的情况

对于此题来说，$f_{i,j}$ 表示所有将 $[i, j]$ 这个区间中的石子合并成一堆的方案的所有集合中的最小代价。

如果直接对 $i, j$ 进行从 $1∼n$ 进行迭代的话是错误的，因为这里的*状态转移*过程是将左右两堆已经合并好的合并成一个大堆，所以得先合并小堆。

所以区间 $ \text{DP}$ 这里比较特殊，我们对区间长度 $\text{len}$ 进行遍历，这样大区间就会依赖于小区间计算出来的结果。



#### 完整C++ 代码

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 310, INF = 0x3f3f3f3f;

int n;
int s[N], dp[N][N];

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++) 
    {
        cin >> s[i];
        s[i] += s[i - 1];
    }
    
    for (int len = 2; len <= n; len++)
        for (int l = 1; l + len - 1 <= n; l++)
        {
            int r = l + len - 1;
            dp[l][r] = INF;
            for (int d = l; d + 1 <= r; d++)              // 假设将区间划分成[l, d] 和 [d + 1, r]
            {
                dp[l][r] = min(dp[l][r], dp[l][d] + dp[d + 1][r] + (s[r] - s[l - 1]));
            }
        }
        
    // 或者下面初始化写法:
    // memset(dp, INF, sizeof dp);
    // for (int len = 1; len <= n; len++)
    //     for (int l = 1; l + len - 1 <= n; l++)
    //     {
    //         int r = l + len - 1;
    //         if (len == 1) dp[l][r] = 0;                   // 长度为1不需要代价
    //         else
    //         {
    //             for (int d = l; d + 1 <= r; d++)              // 假设将区间划分成[l, d] 和 [d + 1, r]
    //                 dp[l][r] = min(dp[l][r], dp[l][d] + dp[d + 1][r] + (s[r] - s[l - 1]));
    //         }
    //     }
    
    cout << dp[1][n] << endl;
}
```



#### 拓展

本题其实是还有一道变式

>### 320. 能量项链
>
>#### 题目描述
>
>在 $\text{Mars}$ 星球上，每个 $\text{Mars}$ 人都随身佩带着一串能量项链，在项链上有 $N$ 颗能量珠。
>
>能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。
>
>并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。
>
>因为只有这样，通过吸盘（吸盘是 $\text{Mars}$ 人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。
>
>如果前一颗能量珠的头标记为 $m$，尾标记为 $r$，后一颗能量珠的头标记为 $r$，尾标记为 $n$，则聚合后释放的能量为 $m×r×n$（$\text{Mars}$ 单位），新产生的珠子的头标记为 $m$，尾标记为 $n$。
>
>需要时，$\text{Mars}$ 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。
>
>显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。
>
>例如：设 $N=4$，$4$ 颗珠子的头标记与尾标记依次为 $(2，3)(3，5)(5，10)(10，2)$。
>
>我们用记号 $⊕$ 表示两颗珠子的聚合操作，$(j⊕k)$ 表示第 $j$，$k$ 两颗珠子聚合后所释放的能量。则第 $4、1$ 两颗珠子聚合后释放的能量为：$(4⊕1)=10×2×3=60$。
>
>这一串项链可以得到最优值的一个聚合顺序所释放的总能量为 $((4⊕1)⊕2)⊕3)=10×2×3+10×3×5+10×5×10=710$。
>
>#### 输入格式
>
>输入的第一行是一个正整数 $N$，表示项链上珠子的个数。
>
>第二行是 $N$ 个用空格隔开的正整数，所有的数均不超过 $1000$，第 $i$ 个数为第 $i$ 颗珠子的头标记，当 $i<N$ 时，第 $i$ 颗珠子的尾标记应该等于第 $i+1$ 颗珠子的头标记，第 $N$ 颗珠子的尾标记应该等于第 $1$ 颗珠子的头标记。
>
>至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。
>
>#### 输出格式
>
>输出只有一行，是一个正整数 $E$，为一个最优聚合顺序所释放的总能量。
>
>#### 数据范围
>
>$4≤N≤100$,
>$1≤E≤2.1×10^9$
>
>#### 输入样例：
>
>```
>4
>2 3 5 10
>```
>
>#### 输出样例：
>
>```
>710
>```
>
>---
>
>#### 算法刨析
>
>这题主要的变化在两个部分：
>
>1. 环形合并
>
>  这一题咋一看就和石子合并这一题基本一样，但是是个环形，所以这题可以简单思考为如何断链成一排石子。
>
>   很朴素的想法是，枚举每一个可能的断链点，如 $1,2...n$, 然后分别使用石子合并模板。
>
>   不好的消息是这种做法的时间复杂度是 $O(n^4)$, 这题给的 $n$ 范围在 $200$ 以内，会 $\text{TLE}$。
>
>   此题的通解是：
>$$
>   \begin{matrix} 1\ \underbrace{ 2\ \ 3\dots \ n\ \ 1}\ 2\dots n \\ len=n \to \text{可以看作是环在 1,2 处断链} \end{matrix}
> $$
> 
> 
>   ​	即我们只需要构造一个长度为 $2n$ 的石子合并问题即可，后面 $n$ 堆的石子和前面 $n$ 堆石子完全一样，直接使用石子合并模板对这 $2n$ 堆石子进行求 $\max$ 和 $\min$ 即可。时间复杂度也从 $O(n^4)$ 降到 $O(n^3)$。
>
> 2. 聚合操作
>
>  这里的聚合操作不是简单的石子合并了，有点像矩阵的味道。
>
>   对于样例，$(2，3)(3，5)(5，10)(10，2)\to2,\ 3,\ 5,\ 10,\ 2$
>
>   将这 $4$ 颗能量珠抽象为 $5$ 个数，然后对这 $5$ 个数套用石子合并模板。
>
>   注意这里状态计算的时候，和石子合并不同，石子合并是将 $[l,r]$ 分成 $[l,d]$ 和 $[d+1, r]$ 两个区间；但是这里是划分成$[l,d]$ 和 $[d, r]$ 两个区间,这里的划分点 $d$ 是共用的:
>$$
>   \begin{matrix} \underbrace{ 2,\ 3,} \underbrace{ \ 5,\ 10,\ 2} \\ [2,3]\ \ \ \ [3,2] \end{matrix}
> $$
>   以及这里的区间长度最少从 $3$ 开始，因为 $\text{len}=2$ 时只是一颗能量珠，不需要合并，可以省去一次判断。
> 
>   以及最终的区间长度应该是 $n+1$。
>
> #### 完整C++代码
>
>```c++
>#include <iostream>
>
>using namespace std;
>
>const int N = 300;
>
>int n;
>int w[N], dp[N][N];
>
>int main()
>{
>   cin >> n;
>   for (int i = 1; i <= n; i++) {
>        cin >> w[i];
>        w[i + n] = w[i];
>    }
>    for (int len = 3; len <= n + 1; len++)       // 注意这里len得从3开始，且取到n+1
>        for (int l = 1; l + len - 1 <= n * 2; l++)
>        {
>            int r = l + len - 1;
>            for (int d = l + 1; d < r; d++)
>            {
>                dp[l][r] = max(dp[l][r], dp[l][d] + dp[d][r] + w[l] * w[d] * w[r]);
>            }
>        }
>    int res = 0;
>    for (int i = 1; i <= n; i++)
>    {
>        int j = i + n;               // 注意这里是因为区间长度为n+1
>        res = max(res, dp[i][j]);
>    }
>    cout << res << endl;
>    return 0;
> }
> ```

---

### AcWing 479. 加分二叉树

#### 题目描述

>### 479. 加分二叉树
>
>设一个 nn 个节点的二叉树 tree 的中序遍历为（1,2,3,…,n1,2,3,…,n），其中数字 1,2,3,…,n1,2,3,…,n 为节点编号。
>
>每个节点都有一个分数（均为正整数），记第 ii 个节点的分数为 didi，tree 及它的每个子树都有一个加分，任一棵子树 subtree（也包含 tree 本身）的加分计算方法如下：     
>
>subtree的左子树的加分 ×× subtree的右子树的加分 ＋＋ subtree的根的分数 
>
>若某个子树为空，规定其加分为 11。
>
>叶子的加分就是叶节点本身的分数，不考虑它的空子树。
>
>试求一棵符合中序遍历为（1,2,3,…,n1,2,3,…,n）且加分最高的二叉树 tree。
>
>要求输出： 
>
>（1）tree的最高加分 
>
>（2）tree的前序遍历
>
>#### 输入格式
>
>第 11 行：一个整数 nn，为节点个数。 
>
>第 22 行：nn 个用空格隔开的整数，为每个节点的分数（0<0<分数<100<100）。
>
>#### 输出格式
>
>第 11 行：一个整数，为最高加分（结果不会超过`int`范围）。     
>
>第 22 行：nn 个用空格隔开的整数，为该树的前序遍历。如果存在多种方案，则输出字典序最小的方案。
>
>#### 数据范围
>
>$n<30$
>
>#### 输入样例：
>
>```
>5
>5 7 1 2 10
>```
>
>##### 输出样例：
>
>```
>145
>3 1 2 4 5
>```

#### 算法剖析

这里选这题作为模板是因为这是一道求区间 $\text{DP}$ 具体方案的题目，和之前的石子合并求最大最小代价是不一样的。

求区间 $\text{DP}$ 具体方案的通用做法是：

通过使用 $g_{i,j}$ 记录区间 $[i,j]$ 中最大价值时的划分点 $d$ ，在使用完区间合并模板后，只需要使用一次 $\text{dfs}$ 即可找到每一次最大价值的划分点。

#### 完整C++ 代码

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 50, INF = 0x3f3f3f3f;

int n;
int w[N];
int dp[N][N], g[N][N];

void dfs(int l, int r)
{   
    if (l > r) return;
    int d = g[l][r];
    cout << d << " ";
    dfs(l, d - 1);
    dfs(d + 1, r);
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> w[i];
    memset(dp, -INF, sizeof dp);
    
    for (int len = 1; len <= n; len++)
        for (int l = 1; l + len - 1 <= n; l++)
        {
            int r = l + len - 1;
            if (len == 1)           // 这题因为对len=1情况特殊规定了，所以得使用模板的第2种写法
            {
                dp[l][r] = w[l];
                g[l][r] = l;
            }
            else
                for (int d = l; d <= r; d++)
                {   
                    int left = dp[l][d - 1], right = dp[d + 1][r];
                    if (d == l)     // 题目种
                        left = 1;
                    if (d == r)
                        right = 1;
                    if (dp[l][r] < left * right + w[d])
                    {
                        dp[l][r] = left * right + w[d];
                        g[l][r] = d;
                    }
                }
        }
    cout << dp[1][n] << endl;
    dfs(1, n);
    return 0;
}
```

---







## 树形DP











---

## 记忆化搜索



















---

# 第六章 贪心





# 第七章 时空复杂度分析

## 由数据范围反推算法复杂度以及算法内容

一般 $\text{ACM}$ 或者笔试题的时间限制是 $1$ 秒或 $2$ 秒，
在这种情况下，$\text{C}$++ 代码中的操作次数控制在 $10^7 \sim 10^8$ 为最佳。
下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择:

1. $n \le 30$,指数级别,dfs+剪枝，状态压缩dp

2. $n \le 10^2 =>O(n^3)$，floyd，dp，高斯消元

3. $n \le 10^3 => O(n^2)$，$O(n^2log n)$，dp，二分，朴素版Dikstra、朴素版Prim、Bellman-Ford

4. $n \le 10^4 => O(n\sqrt{n})$，块状链表、分块、莫队

5. $n \le 10^5 =>O(nlogn)=>$各种sort，线段树、树状数组、setmap、heap、拓扑排序、dikstratheap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树

6. $n\le 10^6 =>O(n)$,以及常数较小的 $O(nlogn)$ 算法 $=>$ 单调队列、hash、双指针扫描、BFS、并查集,
   kmp、AC自动机，常数比较小的 $O(nlogn)$ 的做法:sort、树状数组、heap、dikstra、spfa

7. $n \le 10^7 =>O(n)$，双指针扫描、kmp、AC自动机、线性筛素数
8. $n \le 10^9=>O(\sqrt n)$，判断质数

9. $n \le 10^{18} =>O(logn)$，最大公约数，快速幂，数位DP
10. $n\le 10^{1000} => O((logn)^2)$，高精度加减乘除. 
11. $n\le 10^{100000} => 0(logk \ast loglogk)$，$k$表示位数，高精度加减、FFT/NTT
